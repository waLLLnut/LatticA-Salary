// SPDX-License-Identifier: BSL-1.1
/**
 * ConfidentialPool - ZK-based Confidential Salary Pool
 *
 * Enables confidential salary withdrawals using ZK proofs.
 * Employees can prove they're entitled to a certain amount
 * without revealing the actual salary on-chain.
 *
 * Copyright (c) 2025 waLLLnut
 * Project: LatticA
 * License: BSL 1.1 (Change Date: 2030-01-01, Change License: Apache-2.0)
 *
 * Contact: walllnut@walllnut.com
 * Maintainer: Seunghwan Lee <shlee@walllnut.com>
 */

pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

/**
 * @title IVerifier
 * @notice Interface for the ZK proof verifier (generated by snarkjs)
 */
interface IVerifier {
    function verifyProof(
        uint256[2] calldata _pA,
        uint256[2][2] calldata _pB,
        uint256[2] calldata _pC,
        uint256[4] calldata _pubSignals
    ) external view returns (bool);
}

/**
 * @title ConfidentialPool
 * @notice A pool contract that enables confidential salary withdrawals
 * @dev Uses ZK proofs to verify withdrawal eligibility without revealing amounts
 */
contract ConfidentialPool is Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;

    // ============ State Variables ============

    /// @notice The USDT token contract
    IERC20 public immutable usdt;

    /// @notice The ZK verifier contract
    IVerifier public verifier;

    /// @notice Merkle tree levels (supports 2^20 = ~1M commitments)
    uint256 public constant LEVELS = 20;

    /// @notice Current Merkle root of all salary commitments
    bytes32 public merkleRoot;

    /// @notice Mapping of nullifiers to prevent double-spending
    mapping(bytes32 => bool) public nullifiers;

    /// @notice Mapping of commitments that have been registered
    mapping(bytes32 => bool) public commitments;

    /// @notice Array of all commitment leaves for Merkle tree reconstruction
    bytes32[] public commitmentLeaves;

    /// @notice Total deposited amount in the pool
    uint256 public totalDeposited;

    /// @notice Total withdrawn amount from the pool
    uint256 public totalWithdrawn;

    /// @notice Admin addresses that can register commitments
    mapping(address => bool) public admins;

    // ============ Events ============

    event Deposited(address indexed from, uint256 amount);
    event CommitmentRegistered(bytes32 indexed commitment, uint256 indexed index);
    event Withdrawn(address indexed to, uint256 amount, bytes32 indexed nullifier);
    event MerkleRootUpdated(bytes32 indexed oldRoot, bytes32 indexed newRoot);
    event VerifierUpdated(address indexed oldVerifier, address indexed newVerifier);
    event AdminAdded(address indexed admin);
    event AdminRemoved(address indexed admin);

    // ============ Errors ============

    error InvalidProof();
    error NullifierAlreadyUsed();
    error CommitmentAlreadyRegistered();
    error InsufficientPoolBalance();
    error InvalidAmount();
    error NotAdmin();
    error ZeroAddress();

    // ============ Modifiers ============

    modifier onlyAdmin() {
        if (!admins[msg.sender] && msg.sender != owner()) revert NotAdmin();
        _;
    }

    // ============ Constructor ============

    /**
     * @notice Initialize the ConfidentialPool
     * @param _usdt Address of the USDT token
     * @param _verifier Address of the ZK verifier contract
     */
    constructor(address _usdt, address _verifier) Ownable(msg.sender) {
        if (_usdt == address(0)) revert ZeroAddress();
        usdt = IERC20(_usdt);
        verifier = IVerifier(_verifier);
        admins[msg.sender] = true;
    }

    // ============ Admin Functions ============

    /**
     * @notice Add an admin
     * @param admin Address to add as admin
     */
    function addAdmin(address admin) external onlyOwner {
        if (admin == address(0)) revert ZeroAddress();
        admins[admin] = true;
        emit AdminAdded(admin);
    }

    /**
     * @notice Remove an admin
     * @param admin Address to remove from admins
     */
    function removeAdmin(address admin) external onlyOwner {
        admins[admin] = false;
        emit AdminRemoved(admin);
    }

    /**
     * @notice Update the ZK verifier contract
     * @param _verifier New verifier address
     */
    function setVerifier(address _verifier) external onlyOwner {
        emit VerifierUpdated(address(verifier), _verifier);
        verifier = IVerifier(_verifier);
    }

    /**
     * @notice Deposit USDT into the pool
     * @param amount Amount of USDT to deposit
     */
    function deposit(uint256 amount) external onlyAdmin {
        if (amount == 0) revert InvalidAmount();

        usdt.safeTransferFrom(msg.sender, address(this), amount);
        totalDeposited += amount;

        emit Deposited(msg.sender, amount);
    }

    /**
     * @notice Register a salary commitment
     * @dev The commitment is Poseidon(encryptedSalary, employeeSecret, nonce)
     * @param commitment The salary commitment hash
     */
    function registerCommitment(bytes32 commitment) external onlyAdmin {
        if (commitments[commitment]) revert CommitmentAlreadyRegistered();

        commitments[commitment] = true;
        commitmentLeaves.push(commitment);

        emit CommitmentRegistered(commitment, commitmentLeaves.length - 1);
    }

    /**
     * @notice Register multiple commitments in a batch
     * @param _commitments Array of commitments to register
     */
    function registerCommitmentBatch(bytes32[] calldata _commitments) external onlyAdmin {
        for (uint256 i = 0; i < _commitments.length; i++) {
            if (commitments[_commitments[i]]) revert CommitmentAlreadyRegistered();

            commitments[_commitments[i]] = true;
            commitmentLeaves.push(_commitments[i]);

            emit CommitmentRegistered(_commitments[i], commitmentLeaves.length - 1);
        }
    }

    /**
     * @notice Update the Merkle root after adding commitments
     * @dev In production, this would be computed off-chain and verified
     * @param newRoot The new Merkle root
     */
    function updateMerkleRoot(bytes32 newRoot) external onlyAdmin {
        emit MerkleRootUpdated(merkleRoot, newRoot);
        merkleRoot = newRoot;
    }

    // ============ Employee Functions ============

    /**
     * @notice Withdraw salary using a ZK proof
     * @param proof The ZK proof components
     * @param pubSignals Public signals [commitment, nullifier, withdrawAmount, poolRoot]
     * @param recipient Address to receive the USDT
     */
    function withdraw(
        uint256[8] calldata proof,
        uint256[4] calldata pubSignals,
        address recipient
    ) external nonReentrant {
        if (recipient == address(0)) revert ZeroAddress();

        bytes32 nullifier = bytes32(pubSignals[1]);
        uint256 amount = pubSignals[2];
        bytes32 proofRoot = bytes32(pubSignals[3]);

        // Check nullifier hasn't been used
        if (nullifiers[nullifier]) revert NullifierAlreadyUsed();

        // Check pool has sufficient balance
        if (usdt.balanceOf(address(this)) < amount) revert InsufficientPoolBalance();

        // Check the proof uses the current Merkle root
        if (proofRoot != bytes32(uint256(merkleRoot))) revert InvalidProof();

        // Verify the ZK proof
        uint256[2] memory pA = [proof[0], proof[1]];
        uint256[2][2] memory pB = [[proof[2], proof[3]], [proof[4], proof[5]]];
        uint256[2] memory pC = [proof[6], proof[7]];

        if (!verifier.verifyProof(pA, pB, pC, pubSignals)) revert InvalidProof();

        // Mark nullifier as used
        nullifiers[nullifier] = true;
        totalWithdrawn += amount;

        // Transfer USDT
        usdt.safeTransfer(recipient, amount);

        emit Withdrawn(recipient, amount, nullifier);
    }

    // ============ View Functions ============

    /**
     * @notice Get the pool's USDT balance
     */
    function poolBalance() external view returns (uint256) {
        return usdt.balanceOf(address(this));
    }

    /**
     * @notice Get the total number of registered commitments
     */
    function commitmentCount() external view returns (uint256) {
        return commitmentLeaves.length;
    }

    /**
     * @notice Check if a nullifier has been used
     */
    function isNullifierUsed(bytes32 nullifier) external view returns (bool) {
        return nullifiers[nullifier];
    }

    /**
     * @notice Check if a commitment is registered
     */
    function isCommitmentRegistered(bytes32 commitment) external view returns (bool) {
        return commitments[commitment];
    }

    /**
     * @notice Get all commitment leaves for Merkle tree computation
     */
    function getCommitmentLeaves() external view returns (bytes32[] memory) {
        return commitmentLeaves;
    }

    // ============ Emergency Functions ============

    /**
     * @notice Emergency withdraw all funds (owner only)
     * @dev Only use in case of emergency
     */
    function emergencyWithdraw() external onlyOwner {
        uint256 balance = usdt.balanceOf(address(this));
        usdt.safeTransfer(owner(), balance);
    }
}
